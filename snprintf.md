# About formatted output conversion

## snprintf
- %s
    - [snprintf总是会保证处理过的最后一个字节为'\0', 无论其位置是否为缓冲区的最后一个字节](https://stackoverflow.com/questions/7706936/is-snprintf-always-null-terminating)
    - [\*.\*中, 第一个\*表示最小的显示宽度, 第二个\*需要与.配合(上面的链接里面有提到这点: a period must precede the precision specifier),
        用于表示字符串的截取长度](https://stackoverflow.com/a/3154110/5031605)

```c
char buffer[8];
// Left justification
// -----------------------------------------
// | buffer| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
// -----------------------------------------
// | value |'1'|'2'|'3'|'4'|'5'|'6'|' '| 0 |
// -----------------------------------------
snprintf(buffer, sizeof(buffer)/sizeof(buffer[0]), "%-*.*s", 8, 6, "1234567");

// Right justification
// -----------------------------------------
// | buffer| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
// -----------------------------------------
// | value |' '|' '|'1'|'2'|'3'|'4'|'5'| 0 |
// -----------------------------------------
// 参照上面可知, 此处本来写了6个字节, 但是snprintf需要保证最后一个字节为0,
// 因此最后一个字节的'6'被0覆盖
snprintf(buffer, sizeof(buffer)/sizeof(buffer[0]), "%*.*s", 8, 6, "1234567");


// | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |...
// |'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'A'| 'B'|
printf("123456789AB\n");

// | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |...
// |' '|' '|'1'|'2'|'3'|'4'|'5'|'6'|'A'|'B'|...
// printf写到标准输出时, 并不需要有最后一个字节为0的要求, 所以6个字节全部写
// 成功, 当不是写到标准输出时, 需要再研究
printf("%*.*sAB", 8, 6, "123456789");

// | 0 | 1 | 2 | 3 | 4 | 5 |...
// |'1'|'2'|'3'|'4'|'5'|'6'|...
printf("%*.*s\n", 3, 6, "123456789");
```
